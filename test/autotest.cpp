/*
 * autotest.cpp
 *
 *  Created on: Dec 23, 2019
 *      Author: jjmccollum
 */

#include <iostream>
#include <sstream>
#include <string>
#include <list>
#include <vector>
#include <set>
#include <map>
#include <unordered_map>
#include <limits>

#include "cxxopts.hpp"
#include "config.h" //generated by cmake using template config.h.in
#include "autotest.h"
#include "roaring.hh"
#include "pugixml.hpp"
#include "global_stemma.h"
#include "textual_flow.h"
#include "witness.h"
#include "set_cover_solver.h"
#include "apparatus.h"
#include "variation_unit.h"
#include "local_stemma.h"

using namespace std;
using namespace roaring;

//Define a hardcoded path to the test XML file using macros from the config.h header generated by cmake:
string TEST_XML = string(EXAMPLES_DIR) + "/test.xml";

/**
 * Default constructor.
 */
autotest::autotest() {

}

/**
 * Constructs an autotest instance from a list of module names and a map of unit tests, keyed by parent module name.
 */
autotest::autotest(const list<string> & _modules, const map<string, list<string>> & _tests_by_module) {
	//Copy the list of modules and the map of tests for each module:
	modules = list<string>(_modules);
	tests_by_module = map<string, list<string>>(_tests_by_module);
	//Populate a map from each test to its parent module:
	parent_module_by_test = map<string, string>();
	for (pair<string, list<string>> kv : tests_by_module) {
		string module = kv.first;
		list<string> tests = kv.second;
		for (string test : tests) {
			parent_module_by_test[test] = module;
		}
	}
}

/**
 * Default destructor.
 */
autotest::~autotest() {

}

/**
 * Prints a list of all modules in this autotest instance.
 */
void autotest::print_modules() const {
	cout << "Test modules:\n";
	for (string module : modules) {
		cout << module << "\n";
	}
	cout << endl;
	return;
}

/**
 * Prints a list of all unit tests in this autotest instance.
 */
void autotest::print_tests() const {
	cout << "Unit tests:\n";
	for (string module : modules) {
		cout << module << "\n";
		list<string> tests_in_module = tests_by_module.at(module);
		for (string test : tests_in_module) {
			cout << test << "\n";
		}
	}
	cout << endl;
	return;
}

/**
 * Set this autotest instance's target module to the module with the given name.
 * A boolean value is returned indicating whether the autotest instance has a module with the specified name.
 */
bool autotest::set_target_module(const string & _target_module) {
	//Check if there is a module with the given name:
	if (tests_by_module.find(_target_module) != tests_by_module.end()) {
		//If there is, then set the target module:
		target_module = _target_module;
		return true;
	}
	else {
		return false;
	}
}

/**
 * Set this autotest instance's target test to the test with the given name.
 * A boolean value is returned indicating whether the autotest instance has a unit test with the specified name.
 */
bool autotest::set_target_test(const string & _target_test) {
	//Check if there is a unit test with the given name:
	if (parent_module_by_test.find(_target_test) != parent_module_by_test.end()) {
		//If there is, then set the target test and its parent module:
		string _target_module = parent_module_by_test.at(_target_test);
		target_module = _target_module;
		target_test = _target_test;
		return true;
	}
	else {
		return false;
	}
}

/**
 * Runs all (specified) tests for the library, populating the results in the appropriate unit_test, module_test, and library_test data structures.
 */
void autotest::run() {
	//Initialize the container for library-wide test results:
	lib_test.name = "open-cbgm";
	lib_test.modules = list<module_test>();
	//Then proceed for each module:
	string current_module;
	/**
	 * Module common
	 */
	current_module = "common";
	if (target_module.empty() || target_module == current_module) {
		//Initialize a container for module-wide test results:
		module_test mod_test;
		mod_test.name = current_module;
		mod_test.units = list<unit_test>();
		//Then proceed for each unit test:
		string current_unit;
		/**
		 * Unit common_read_xml
		 */
		current_unit = "common_read_xml";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Parse the test XML file:
				pugi::xml_document doc;
				pugi::xml_parse_result result = doc.load_file(TEST_XML.c_str());
				if (!result) {
					u_test.msg += string(result.description()) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		lib_test.modules.push_back(mod_test);
	}
	/**
	 * Module local_stemma
	 */
	current_module = "local_stemma";
	if (target_module.empty() || target_module == current_module) {
		//Initialize a container for module-wide test results:
		module_test mod_test;
		mod_test.name = current_module;
		mod_test.units = list<unit_test>();
		//Do pre-test work:
		pugi::xml_document doc;
		doc.load_file(TEST_XML.c_str());
		pugi::xml_node app_node = doc.select_node("descendant::app[@n=\"B00K0V0U6\"]").node();
		string vu_id = app_node.attribute("n").value();
		string vu_label = app_node.child("label").text().get();
		pugi::xml_node note_node = app_node.child("note");
		pugi::xml_node graph_node = note_node.child("graph");
		//Then proceed for each unit test:
		string current_unit;
		/**
		 * Unit test local_stemma_constructor_1
		 */
		current_unit = "local_stemma_constructor_1";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a local stemma without any split merges, trivial readings, or dropped readings:
				local_stemma ls = local_stemma(graph_node, vu_id, vu_label, set<pair<string, string>>(), set<string>(), set<string>());
				//Check that the ID is the expected_value:
				string expected_id = vu_id;
				string id = ls.get_id();
				if (id != expected_id) {
					u_test.msg += "For variation unit B00K0V0U6, expected ID " + expected_id + ", got " + id + "\n";
				}
				//Check that the label is the expected value:
				string expected_label = vu_label;
				string label = ls.get_label();
				if (label != expected_label) {
					u_test.msg += "For variation unit B00K0V0U6, expected label " + expected_label + ", got " + label + "\n";
				}
				//Check that the graph is the size we expect:
				unsigned int expected_n_vertices = 5;
				unsigned int expected_n_edges = 4;
				unsigned int expected_n_roots = 1;
				unsigned int expected_n_paths = 11;
				if (ls.get_vertices().size() != expected_n_vertices) {
					u_test.msg += "For variation unit B00K0V0U6, expected vertices.size() == " + to_string(expected_n_vertices) + ", got " + to_string(ls.get_vertices().size()) + "\n";
				}
				if (ls.get_edges().size() != expected_n_edges) {
					u_test.msg += "For variation unit B00K0V0U6, expected edges.size() == " + to_string(expected_n_edges) + ", got " + to_string(ls.get_edges().size()) + "\n";
				}
				if (ls.get_roots().size() != expected_n_roots) {
					u_test.msg += "For variation unit B00K0V0U6, expected roots.size() == " + to_string(expected_n_roots) + ", got " + to_string(ls.get_roots().size()) + "\n";
				}
				if (ls.get_paths().size() != expected_n_paths) {
					u_test.msg += "For variation unit B00K0V0U6, expected paths.size() == " + to_string(expected_n_paths) + ", got " + to_string(ls.get_paths().size()) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		//Do more pre-test work:
		app_node = doc.select_node("descendant::app[@n=\"B00K0V0U8\"]").node();
		vu_id = app_node.attribute("n").value();
		vu_label = app_node.child("label").text().get();
		note_node = app_node.child("note");
		graph_node = note_node.child("graph");
		/**
		 * Unit test local_stemma_constructor_2
		 */
		current_unit = "local_stemma_constructor_2";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a local stemma with a connected pair of split readings and a dropped vertex:
				local_stemma ls = local_stemma(graph_node, vu_id, vu_label, set<pair<string, string>>({{"c2", "c"}}), set<string>(), set<string>({"zw-a/b"}));
				//Check that the graph is the size we expect:
				unsigned int expected_n_vertices = 4;
				unsigned int expected_n_edges = 4;
				unsigned int expected_n_roots = 2;
				unsigned int expected_n_paths = 10;
				if (ls.get_vertices().size() != expected_n_vertices) {
					u_test.msg += "For variation unit B00K0V0U8, expected vertices.size() == " + to_string(expected_n_vertices) + ", got " + to_string(ls.get_vertices().size()) + "\n";
				}
				if (ls.get_edges().size() != expected_n_edges) {
					u_test.msg += "For variation unit B00K0V0U8, expected edges.size() == " + to_string(expected_n_edges) + ", got " + to_string(ls.get_edges().size()) + "\n";
				}
				if (ls.get_roots().size() != expected_n_roots) {
					u_test.msg += "For variation unit B00K0V0U8, expected roots.size() == " + to_string(expected_n_roots) + ", got " + to_string(ls.get_roots().size()) + "\n";
				}
				if (ls.get_paths().size() != expected_n_paths) {
					u_test.msg += "For variation unit B00K0V0U8, expected paths.size() == " + to_string(expected_n_paths) + ", got " + to_string(ls.get_paths().size()) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		//Do pre-test work:
		app_node = doc.select_node("descendant::app[@n=\"B00K0V0U4\"]").node();
		vu_id = app_node.attribute("n").value();
		vu_label = app_node.child("label").text().get();
		note_node = app_node.child("note");
		graph_node = note_node.child("graph");
		local_stemma ls = local_stemma(graph_node, vu_id, vu_label, set<pair<string, string>>(), set<string>(), set<string>());
		/**
		 * Unit test local_stemma_path_exists
		 */
		current_unit = "local_stemma_path_exists";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//A path should exist from a reading to itself:
				if (!ls.path_exists("a", "a")) {
					u_test.msg += "For variation unit B00K0V0U4, expected path_exists(\"a\", \"a\") == true, got false\n";
				}
				//Test direct priority of readings:
				if (!ls.path_exists("a", "b")) {
					u_test.msg += "For variation unit B00K0V0U4, expected path_exists(\"a\", \"b\") == true, got false\n";
				}
				//Test transitive priority of readings:
				if (!ls.path_exists("a", "d")) {
					u_test.msg += "For variation unit B00K0V0U4, expected path_exists(\"a\", \"d\") == true, got false\n";
				}
				//Test posteriority of readings:
				if (ls.path_exists("c", "a")) {
					u_test.msg += "For variation unit B00K0V0U4, expected path_exists(\"c\", \"a\") == false, got true\n";
				}
				//Test direct priority of readings:
				if (ls.path_exists("b", "c")) {
					u_test.msg += "For variation unit B00K0V0U4, expected path_exists(\"b\", \"c\") == false, got true\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit test local_stemma_get_path
		 */
		current_unit = "local_stemma_get_path";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//The shortest path from a reading to itself should have weight 0 and cardinality 0:
				float expected_path_weight = 0;
				float path_weight = ls.get_path("a", "a").weight;
				if (path_weight != expected_path_weight) {
					u_test.msg += "For variation unit B00K0V0U4, expected get_path(\"a\", \"a\").weight == " + to_string(expected_path_weight) + ", got " + to_string(path_weight) + "\n";
				}
				int expected_path_cardinality = 0;
				int path_cardinality = ls.get_path("a", "a").cardinality;
				if (path_cardinality != expected_path_cardinality) {
					u_test.msg += "For variation unit B00K0V0U4, expected get_path(\"a\", \"a\").cardinality == " + to_string(expected_path_cardinality) + ", got " + to_string(path_cardinality) + "\n";
				}
				//The shortest path from a reading to a directly posterior reading should have weight 1 and cardinality 1:
				expected_path_weight = 1;
				path_weight = ls.get_path("a", "b").weight;
				if (path_weight != expected_path_weight) {
					u_test.msg += "For variation unit B00K0V0U4, expected get_path(\"a\", \"b\").weight == " + to_string(expected_path_weight) + ", got " + to_string(path_weight) + "\n";
				}
				expected_path_cardinality = 1;
				path_cardinality = ls.get_path("a", "b").cardinality;
				if (path_cardinality != expected_path_cardinality) {
					u_test.msg += "For variation unit B00K0V0U4, expected get_path(\"a\", \"b\").cardinality == " + to_string(expected_path_cardinality) + ", got " + to_string(path_cardinality) + "\n";
				}
				//The shortest path from a reading to a transitively posterior reading should have length and cardinality greater than 1:
				expected_path_weight = 2;
				path_weight = ls.get_path("a", "d").weight;
				if (path_weight != expected_path_weight) {
					u_test.msg += "For variation unit B00K0V0U4, expected get_path(\"a\", \"d\").weight == " + to_string(expected_path_weight) + ", got " + to_string(path_weight) + "\n";
				}
				expected_path_cardinality = 2;
				path_cardinality = ls.get_path("a", "d").cardinality;
				if (path_cardinality != expected_path_cardinality) {
					u_test.msg += "For variation unit B00K0V0U4, expected get_path(\"a\", \"d\").cardinality == " + to_string(expected_path_cardinality) + ", got " + to_string(path_cardinality) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		//Do more pre-test work:
		app_node = doc.select_node("descendant::app[@n=\"B00K0V0U8\"]").node();
		vu_id = app_node.attribute("n").value();
		vu_label = app_node.child("label").text().get();
		note_node = app_node.child("note");
		graph_node = note_node.child("graph");
		ls = local_stemma(graph_node, vu_id, vu_label, set<pair<string, string>>(), set<string>(), set<string>({"zw-a/b"}));
		/**
		 * Unit test local_stemma_common_ancestor_exists
		 */
		current_unit = "local_stemma_common_ancestor_exists";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//A reading should be a common ancestor to itself:
				if (!ls.common_ancestor_exists("a", "a")) {
					u_test.msg += "For variation unit B00K0V0U8, expected common_ancestor_exists(\"a\", \"a\") == true, got false\n";
				}
				//The common ancestor between a reading and one of its descendants should be the earlier reading:
				if (!ls.common_ancestor_exists("a", "c")) {
					u_test.msg += "For variation unit B00K0V0U8, expected common_ancestor_exists(\"a\", \"c\") == true, got false\n";
				}
				//Separate roots should have no common ancestor:
				if (ls.common_ancestor_exists("a", "b")) {
					u_test.msg += "For variation unit B00K0V0U8, expected common_ancestor_exists(\"a\", \"b\") == false, got true\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit test local_stemma_to_dot
		 */
		current_unit = "local_stemma_to_dot";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Test .dot serialization:
				stringstream ss;
				ls.to_dot(ss, false);
				string out = ss.str();
				if (out.empty()) {
					u_test.msg += "The .dot serialization was empty.\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		lib_test.modules.push_back(mod_test);
	}
	/**
	 * Module variation_unit
	 */
	current_module = "variation_unit";
	if (target_module.empty() || target_module == current_module) {
		//Initialize a container for module-wide test results:
		module_test mod_test;
		mod_test.name = current_module;
		mod_test.units = list<unit_test>();
		//Do pre-test work:
		pugi::xml_document doc;
		doc.load_file(TEST_XML.c_str());
		pugi::xml_node app_node_1 = doc.select_node("descendant::app[@n=\"B00K0V0U2\"]").node();
		pugi::xml_node app_node_2 = doc.select_node("descendant::app[@n=\"B00K0V0U4\"]").node();
		pugi::xml_node app_node_3 = doc.select_node("descendant::app[@n=\"B00K0V0U6\"]").node();
		pugi::xml_node app_node_4 = doc.select_node("descendant::app[@n=\"B00K0V0U8\"]").node();
		//Then proceed for each unit test:
		string current_unit;
		/**
		 * Unit test variation_unit_constructor_1
		 */
		current_unit = "variation_unit_constructor_1";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a variation unit with no merging of split readings, no dropped reading types, and no trivial reading types:
				variation_unit vu = variation_unit(app_node_1, false, set<string>(), set<string>());
				//Check that the ID is the expected value:
				string expected_id = "B00K0V0U2";
				string id = vu.get_id();
				if (id != expected_id) {
					u_test.msg += "Expected ID " + expected_id + ", got " + id + "\n";
				}
				//Check that the label is the expected value:
				string expected_label = "Test 0:0/2";
				string label = vu.get_label();
				if (label != expected_label) {
					u_test.msg += "Expected label " + expected_label + ", got " + label + "\n";
				}
				//Check that the readings list is the correct size:
				list<string> readings = vu.get_readings();
				unsigned int expected_readings_size = 2;
				unsigned int readings_size = (unsigned int) readings.size();
				if (readings_size != expected_readings_size) {
					u_test.msg += "Expected readings.size() == " + to_string(expected_readings_size) + ", got " + to_string(readings_size) + "\n";
				}
				//Check that the reading support map is the correct size:
				unordered_map<string, string> reading_support = vu.get_reading_support();
				unsigned int expected_reading_support_size = 5;
				unsigned int reading_support_size = (unsigned int) reading_support.size();
				if (reading_support_size != expected_reading_support_size) {
					u_test.msg += "Expected reading_support.size() == " + to_string(expected_reading_support_size) + ", got " + to_string(reading_support_size) + "\n";
				}
				//Check that the connectivity is correct:
				int expected_connectivity = 5;
				int connectivity = vu.get_connectivity();
				if (connectivity != expected_connectivity) {
					u_test.msg += "Expected connectivity == " + to_string(expected_connectivity) + ", got " + to_string(connectivity) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit test variation_unit_constructor_2
		 */
		current_unit = "variation_unit_constructor_2";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a variation unit with no merging of split readings, no dropped reading types, and no trivial reading types:
				variation_unit vu = variation_unit(app_node_2, false, set<string>(), set<string>());
				//Check that the label defaults to the ID when not provided:
				string expected_label = "B00K0V0U4";
				string label = vu.get_label();
				if (label != expected_label) {
					u_test.msg += "Expected label " + expected_label + ", got " + label + "\n";
				}
				//Check that the connectivity is correctly set to the maximum value when the connectivity value is explicitly "absolute":
				int expected_connectivity = numeric_limits<int>::max();
				int connectivity = vu.get_connectivity();
				if (connectivity != expected_connectivity) {
					u_test.msg += "Expected connectivity == " + to_string(expected_connectivity) + ", got " + to_string(connectivity) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit test variation_unit_constructor_3
		 */
		current_unit = "variation_unit_constructor_3";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a variation unit with no merging of split readings, no dropped reading types, and where defective readings are treated as trivial:
				variation_unit vu = variation_unit(app_node_3, false, set<string>({"defective"}), set<string>());
				//Check that the connectivity is correctly set to the maximum value when no connectivity element is provided:
				int expected_connectivity = numeric_limits<int>::max();
				int connectivity = vu.get_connectivity();
				if (connectivity != expected_connectivity) {
					u_test.msg += "Expected connectivity == " + to_string(expected_connectivity) + ", got " + to_string(connectivity) + "\n";
				}
				//Check that the local stemma for this variation unit has a weight-0 edge where the defective variant is introduced:
				local_stemma ls = vu.get_local_stemma();
				float expected_path_weight = 0;
				if (ls.get_path("b", "bf").weight != expected_path_weight) {
					u_test.msg += "Expected get_local_stemma().get_path(\"b\", \"bf\").weight == " + to_string(expected_path_weight) + ", got " + to_string(ls.get_path("b", "bf").weight) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit test variation_unit_constructor_4
		 */
		current_unit = "variation_unit_constructor_4";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a variation unit with merging of split readings, ambiguous readings dropped, and no trivial reading types:
				variation_unit vu = variation_unit(app_node_4, true, set<string>(), set<string>({"ambiguous"}));
				//Check that the reading support map is the correct size when witnesses are lacunose:
				unordered_map<string, string> reading_support = vu.get_reading_support();
				unsigned int expected_reading_support_size = 3;
				unsigned int reading_support_size = (unsigned int) reading_support.size();
				if (reading_support_size != expected_reading_support_size) {
					u_test.msg += "Expected reading_support.size() == " + to_string(expected_reading_support_size) + ", got " + to_string(reading_support_size) + "\n";
				}
				//Check that the local stemma for this variation unit has edges in both directions between paired split readings:
				local_stemma ls = vu.get_local_stemma();
				bool expected_path_exists = true;
				bool path_exists = ls.path_exists("c", "c2");
				if (path_exists != expected_path_exists) {
					u_test.msg += "Expected get_local_stemma().path_exists(\"c\", \"c2\") == true, got false\n";
				}
				expected_path_exists = true;
				path_exists = ls.path_exists("c2", "c");
				if (path_exists != expected_path_exists) {
					u_test.msg += "Expected get_local_stemma().path_exists(\"c2\", \"c\") == true, got false\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		lib_test.modules.push_back(mod_test);
	}
	/**
	 * Module apparatus
	 */
	current_module = "apparatus";
	if (target_module.empty() || target_module == current_module) {
		//Initialize a container for module-wide test results:
		module_test mod_test;
		mod_test.name = current_module;
		mod_test.units = list<unit_test>();
		//Do pre-test work:
		pugi::xml_document doc;
		doc.load_file(TEST_XML.c_str());
		pugi::xml_node tei_node = doc.child("TEI");
		bool merge_splits = false;
		set<string> trivial_reading_types = set<string>({"defective", "orthographic"});
		set<string> dropped_reading_types = set<string>();
		//Then proceed for each unit test:
		string current_unit;
		/**
		 * Unit apparatus_constructor
		 */
		current_unit = "apparatus_constructor";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct an apparatus:
				apparatus app = apparatus(tei_node, merge_splits, trivial_reading_types, dropped_reading_types);
				//Check if its number of witnesses is correct:
				unsigned int expected_n_witnesses = 5;
				unsigned int n_witnesses = (unsigned int) app.get_list_wit().size();
				if (n_witnesses != expected_n_witnesses) {
					u_test.msg += "Expected list_wit.size() == " + to_string(expected_n_witnesses) + ", got " + to_string(n_witnesses) + "\n";
				}
				//Check if its number of variation units is correct:
				unsigned int expected_n_variation_units = 4;
				unsigned int n_variation_units = (unsigned int) app.get_variation_units().size();
				if (n_variation_units != expected_n_variation_units) {
					u_test.msg += "Expected variation_units.size() == " + to_string(expected_n_variation_units) + ", got " + to_string(n_variation_units) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		//Do more pre-test work:
		apparatus app = apparatus(tei_node, merge_splits, trivial_reading_types, dropped_reading_types);
		/**
		 * Unit apparatus_get_extant_passages_for_witness
		 */
		current_unit = "apparatus_get_extant_passages_for_witness";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Test if the apparatus correctly evaluates the number of passages at which a witness is extant:
				unsigned int expected_extant = 3;
				unsigned int extant = app.get_extant_passages_for_witness("E");
				if (extant != expected_extant) {
					u_test.msg += "Expected number of extant passages for witness E to be " + to_string(expected_extant) + ", got " + to_string(extant) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		lib_test.modules.push_back(mod_test);
	}
	/**
	 * Module set_cover_solver
	 */
	current_module = "set_cover_solver";
	if (target_module.empty() || target_module == current_module) {
		//Initialize a container for module-wide test results:
		module_test mod_test;
		mod_test.name = current_module;
		mod_test.units = list<unit_test>();
		//Do pre-test work:
		Roaring target = Roaring::bitmapOf(4, 0, 1, 2, 3);
		vector<set_cover_row> rows = vector<set_cover_row>();
		set_cover_row row_a;
		row_a.id = "A";
		row_a.agreements = Roaring::bitmapOf(0);
		row_a.explained = Roaring::bitmapOf(3, 0, 2, 3);
		row_a.cost = 3;
		rows.push_back(row_a);
		set_cover_row row_b;
		row_b.id = "B";
		row_b.agreements = Roaring::bitmapOf(0);
		row_b.explained = Roaring::bitmapOf(2, 0, 3);
		row_b.cost = 2;
		rows.push_back(row_b);
		set_cover_row row_c;
		row_c.id = "C";
		row_a.agreements = Roaring::bitmapOf(0);
		row_c.explained = Roaring::bitmapOf(4, 0, 1, 2, 3);
		row_c.cost = 4;
		rows.push_back(row_c);
		//Then proceed for each unit test:
		string current_unit;
		/**
		 * Unit set_cover_solver_constructor
		 */
		current_unit = "set_cover_solver_constructor";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a new set cover solver:
				set_cover_solver scs = set_cover_solver(rows, target);
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		//Do more pre-test work:
		set_cover_solver scs = set_cover_solver(rows, target);
		/**
		 * Unit set_cover_solver_get_unique_rows
		 */
		current_unit = "set_cover_solver_get_unique_rows";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Make sure that unique coverage rows are correctly identified:
				Roaring unique_rows = scs.get_unique_rows();
				unsigned int expected_unique_rows_size = 1;
				unsigned int unique_rows_size = (unsigned int) unique_rows.cardinality();
				if (unique_rows_size != expected_unique_rows_size) {
					u_test.msg += "Expected unique_rows.cardinality() == " + to_string(expected_unique_rows_size) + ", got " + to_string(unique_rows_size) + "\n";
				}
				else {
					if (!unique_rows.contains(2)) {
						u_test.msg += "Expected unique_rows.contains(2) == true, got false\n";
					}
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit set_cover_solver_get_trivial_solution
		 */
		current_unit = "set_cover_solver_get_trivial_solution";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Make sure that the trivial solution is correct:
				set_cover_solution trivial_solution = scs.get_trivial_solution();
				//Trivial solution should consist of one row:
				list<set_cover_row> solution_rows = trivial_solution.rows;
				unsigned int expected_solution_rows_size = 1;
				unsigned int solution_rows_size = (unsigned int) solution_rows.size();
				if (solution_rows_size != expected_solution_rows_size) {
					u_test.msg += "Expected trivial_solution.rows.size() == " + to_string(expected_solution_rows_size) + ", got " + to_string(solution_rows_size) + "\n";
				}
				else {
					//That row should be row "C":
					set_cover_row solution_row = solution_rows.front();
					string expected_id = "C";
					string id = solution_row.id;
					if (id != expected_id) {
						u_test.msg += "Expected trivial solution ID to be " + expected_id + ", got " + id + "\n";
					}
				}
				//Make sure the trivial solution has the correct cost:
				float expected_cost = 4;
				float cost = trivial_solution.cost;
				if (cost != expected_cost) {
					u_test.msg += "Expected trivial_solution.cost == " + to_string(expected_cost) + ", got " + to_string(cost) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		//Do more pre-test work:
		rows.pop_back(); //remove row C, which is a trivial solution
		set_cover_row row_d;
		row_d.id = "D";
		row_d.agreements = Roaring::bitmapOf(2, 1, 2);
		row_d.explained = Roaring::bitmapOf(3, 1, 2, 3);
		row_d.cost = 1;
		rows.push_back(row_d);
		scs = set_cover_solver(rows, target);
		/**
		 * Unit set_cover_solver_get_greedy_solution
		 */
		current_unit = "set_cover_solver_get_greedy_solution";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Make sure that the greedy solution is correct:
				set_cover_solution greedy_solution = scs.get_greedy_solution();
				//Greedy solution should consist of two rows:
				list<set_cover_row> solution_rows = greedy_solution.rows;
				unsigned int expected_solution_rows_size = 2;
				unsigned int solution_rows_size = (unsigned int) solution_rows.size();
				if (solution_rows_size != expected_solution_rows_size) {
					u_test.msg += "Expected greedy_solution.rows.size() == " + to_string(expected_solution_rows_size) + ", got " + to_string(solution_rows_size) + "\n";
				}
				//Make sure the greedy solution has the correct cost:
				float expected_cost = 3;
				float cost = greedy_solution.cost;
				if (cost != expected_cost) {
					u_test.msg += "Expected greedy_solution.cost == " + to_string(expected_cost) + ", got " + to_string(cost) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		lib_test.modules.push_back(mod_test);
	}
	/**
	 * Module witness
	 */
	current_module = "witness";
	if (target_module.empty() || target_module == current_module) {
		//Initialize a container for module-wide test results:
		module_test mod_test;
		mod_test.name = current_module;
		mod_test.units = list<unit_test>();
		//Then proceed for each unit test:
		string current_unit;
		//Do pre-test work:
		pugi::xml_document doc;
		doc.load_file(TEST_XML.c_str());
		pugi::xml_node tei_node = doc.child("TEI");
		bool merge_splits = false;
		set<string> trivial_reading_types = set<string>({"defective", "orthographic"});
		set<string> dropped_reading_types = set<string>({"ambiguous"});
		apparatus app = apparatus(tei_node, merge_splits, trivial_reading_types, dropped_reading_types);
		/**
		 * Unit witness_constructor_1
		 */
		current_unit = "witness_constructor_1";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a new witness with genealogical relationships to all other witnesses:
				witness wit = witness("A", app);
				//Check that the ID is correct:
				string expected_id = "A";
				string id = wit.get_id();
				if (id != expected_id) {
					u_test.msg += "Expected witness ID to be " + expected_id + ", got " + id + "\n";
				}
				//Check that the size of the genealogical_comparison map is correct:
				unsigned int expected_genealogical_comparisons_size = 5;
				unsigned int genealogical_comparisons_size = (unsigned int) wit.get_genealogical_comparisons().size();
				if (genealogical_comparisons_size != expected_genealogical_comparisons_size) {
					u_test.msg += "Expected genealogical_comparisons.size() == " + to_string(expected_genealogical_comparisons_size) + ", got " + to_string(genealogical_comparisons_size) + "\n";
				}
				//Check that the size of the potential ancestors list is correct:
				unsigned int expected_potential_ancestor_ids_size = 0;
				unsigned int potential_ancestor_ids_size = (unsigned int) wit.get_potential_ancestor_ids().size();
				if (potential_ancestor_ids_size != expected_potential_ancestor_ids_size) {
					u_test.msg += "Expected potential_ancestor_ids.size() == " + to_string(expected_potential_ancestor_ids_size) + ", got " + to_string(potential_ancestor_ids_size) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit witness_constructor_2
		 */
		current_unit = "witness_constructor_2";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a new witness with genealogical relationships to one other witness using the copy constructor:
				list<genealogical_comparison> comps = list<genealogical_comparison>();
				genealogical_comparison comp_A;
				comp_A.primary_wit = "B";
				comp_A.secondary_wit = "A";
				comp_A.extant = Roaring::bitmapOf(3, 0, 1, 2);
				comp_A.agreements = Roaring::bitmapOf(2, 0, 1);
				comp_A.prior = Roaring::bitmapOf(0);
				comp_A.posterior = Roaring::bitmapOf(1, 2);
				comp_A.norel = Roaring::bitmapOf(0);
				comp_A.unclear = Roaring::bitmapOf(0);
				comp_A.explained = Roaring::bitmapOf(3, 0, 1, 2);
				comp_A.cost = 1;
				comps.push_back(comp_A);
				genealogical_comparison comp_B;
				comp_B.primary_wit = "B";
				comp_B.secondary_wit = "B";
				comp_B.extant = Roaring::bitmapOf(4, 0, 1, 2, 3);
				comp_B.agreements = Roaring::bitmapOf(4, 0, 1, 2, 3);
				comp_B.prior = Roaring::bitmapOf(0);
				comp_B.posterior = Roaring::bitmapOf(0);
				comp_B.norel = Roaring::bitmapOf(0);
				comp_B.unclear = Roaring::bitmapOf(0);
				comp_B.explained = Roaring::bitmapOf(4, 0, 1, 2, 3);
				comp_B.cost = 0;
				comps.push_back(comp_B);
				witness wit = witness("B", comps);
				//Check that the ID is correct:
				string expected_id = "B";
				string id = wit.get_id();
				if (id != expected_id) {
					u_test.msg += "Expected witness ID to be " + expected_id + ", got " + id + "\n";
				}
				//Check that the size of the genealogical_comparison map is correct:
				unsigned int expected_genealogical_comparisons_size = 2;
				unsigned int genealogical_comparisons_size = (unsigned int) wit.get_genealogical_comparisons().size();
				if (genealogical_comparisons_size != expected_genealogical_comparisons_size) {
					u_test.msg += "Expected genealogical_comparisons.size() == " + to_string(expected_genealogical_comparisons_size) + ", got " + to_string(genealogical_comparisons_size) + "\n";
				}
				//Check that the size of the potential ancestors list is correct:
				unsigned int expected_potential_ancestor_ids_size = 1;
				unsigned int potential_ancestor_ids_size = (unsigned int) wit.get_potential_ancestor_ids().size();
				if (potential_ancestor_ids_size != expected_potential_ancestor_ids_size) {
					u_test.msg += "Expected potential_ancestor_ids.size() == " + to_string(expected_potential_ancestor_ids_size) + ", got " + to_string(potential_ancestor_ids_size) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit witness_get_genealogical_comparison_for_witness_1
		 */
		current_unit = "witness_get_genealogical_comparison_for_witness_1";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				witness wit = witness("B", app);
				genealogical_comparison comp = wit.get_genealogical_comparison_for_witness("D");
				//Check that B's mutually extant passages with D are correct:
				Roaring expected_extant = Roaring::bitmapOf(4, 0, 1, 2, 3);
				Roaring extant = comp.extant;
				if ((extant ^ expected_extant).cardinality() != 0) {
					u_test.msg += "Expected extant passages bitmap for B relative to D == " + expected_extant.toString() + ", got " + extant.toString() + "\n";
				}
				//Check that B's agreements with D are correct:
				Roaring expected_agreements = Roaring::bitmapOf(0);
				Roaring agreements = comp.agreements;
				if ((agreements ^ expected_agreements).cardinality() != 0) {
					u_test.msg += "Expected agreements bitmap for B relative to D == " + expected_agreements.toString() + ", got " + agreements.toString() + "\n";
				}
				//Check that B's prior readings relative to D are correct:
				Roaring expected_prior = Roaring::bitmapOf(2, 0, 1);
				Roaring prior = comp.prior;
				if ((prior ^ expected_prior).cardinality() != 0) {
					u_test.msg += "Expected prior readings bitmap for B relative to D == " + expected_prior.toString() + ", got " + prior.toString() + "\n";
				}
				//Check that B's posterior readings relative to D are correct:
				Roaring expected_posterior = Roaring::bitmapOf(0);
				Roaring posterior = comp.posterior;
				if ((posterior ^ expected_posterior).cardinality() != 0) {
					u_test.msg += "Expected posterior readings bitmap for B relative to D == " + expected_posterior.toString() + ", got " + posterior.toString() + "\n";
				}
				//Check that B's readings unrelated to those of D are correct:
				Roaring expected_norel = Roaring::bitmapOf(1, 2);
				Roaring norel = comp.norel;
				if ((norel ^ expected_norel).cardinality() != 0) {
					u_test.msg += "Expected norel readings bitmap for B relative to D == " + expected_norel.toString() + ", got " + norel.toString() + "\n";
				}
				//Check that B's readings with an unclear relationship to those of D are correct:
				Roaring expected_unclear = Roaring::bitmapOf(1, 3);
				Roaring unclear = comp.unclear;
				if ((unclear ^ expected_unclear).cardinality() != 0) {
					u_test.msg += "Expected unclear readings bitmap for B relative to D == " + expected_unclear.toString() + ", got " + unclear.toString() + "\n";
				}
				//Check that B's explained readings by D are correct:
				Roaring expected_explained_readings = Roaring::bitmapOf(0);
				Roaring explained_readings = comp.explained;
				if ((explained_readings ^ expected_explained_readings).cardinality() != 0) {
					u_test.msg += "Expected explained readings bitmap for B relative to D == " + expected_explained_readings.toString() + ", got " + explained_readings.toString() + "\n";
				}
				//Check that the genealogical cost of B relative to D is correct:
				float expected_cost = 0;
				float cost = comp.cost;
				if (cost != expected_cost) {
					u_test.msg += "Expected genealogical cost for B relative to D == " + to_string(expected_cost) + ", got " + to_string(cost) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit witness_get_genealogical_comparison_for_witness_2
		 */
		current_unit = "witness_get_genealogical_comparison_for_witness_2";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				witness wit = witness("E", app);
				genealogical_comparison comp = wit.get_genealogical_comparison_for_witness("A");
				//Check that E's mutually extant passages with A are correct:
				Roaring expected_extant = Roaring::bitmapOf(3, 0, 1, 2);
				Roaring extant = comp.extant;
				if ((extant ^ expected_extant).cardinality() != 0) {
					u_test.msg += "Expected extant passages bitmap for E relative to A == " + expected_extant.toString() + ", got " + extant.toString() + "\n";
				}
				//Check that E's agreements with A are correct:
				Roaring expected_agreements = Roaring::bitmapOf(0);
				Roaring agreements = comp.agreements;
				if ((agreements ^ expected_agreements).cardinality() != 0) {
					u_test.msg += "Expected agreements bitmap for E relative to A == " + expected_agreements.toString() + ", got " + agreements.toString() + "\n";
				}
				//Check that E's prior readings relative to A are correct:
				Roaring expected_prior = Roaring::bitmapOf(0);
				Roaring prior = comp.prior;
				if ((prior ^ expected_prior).cardinality() != 0) {
					u_test.msg += "Expected prior readings bitmap for E relative to A == " + expected_prior.toString() + ", got " + prior.toString() + "\n";
				}
				//Check that E's posterior readings relative to A are correct:
				Roaring expected_posterior = Roaring::bitmapOf(3, 0, 1, 2);
				Roaring posterior = comp.posterior;
				if ((posterior ^ expected_posterior).cardinality() != 0) {
					u_test.msg += "Expected posterior readings bitmap for E relative to A == " + expected_posterior.toString() + ", got " + posterior.toString() + "\n";
				}
				//Check that E's readings unrelated to those of A are correct:
				Roaring expected_norel = Roaring::bitmapOf(0);
				Roaring norel = comp.norel;
				if ((norel ^ expected_norel).cardinality() != 0) {
					u_test.msg += "Expected norel readings bitmap for E relative to A == " + expected_norel.toString() + ", got " + norel.toString() + "\n";
				}
				//Check that E's readings with an unclear relationship to those of A are correct:
				Roaring expected_unclear = Roaring::bitmapOf(0);
				Roaring unclear = comp.unclear;
				if ((unclear ^ expected_unclear).cardinality() != 0) {
					u_test.msg += "Expected unclear readings bitmap for E relative to A == " + expected_unclear.toString() + ", got " + unclear.toString() + "\n";
				}
				//Check that E's explained readings by A are correct:
				Roaring expected_explained_readings = Roaring::bitmapOf(3, 0, 1, 2);
				Roaring explained_readings = comp.explained;
				if ((explained_readings ^ expected_explained_readings).cardinality() != 0) {
					u_test.msg += "Expected explained readings bitmap for E relative to A == " + expected_explained_readings.toString() + ", got " + explained_readings.toString() + "\n";
				}
				//Check that the genealogical cost of E relative to A is correct:
				float expected_cost = 4;
				float cost = comp.cost;
				if (cost != expected_cost) {
					u_test.msg += "Expected genealogical cost for E relative to A == " + to_string(expected_cost) + ", got " + to_string(cost) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit witness_get_genealogical_comparison_for_witness_3
		 */
		current_unit = "witness_get_genealogical_comparison_for_witness_3";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				witness wit = witness("E", app, true);
				genealogical_comparison comp = wit.get_genealogical_comparison_for_witness("A");
				//Check that E's explained readings by A are correct:
				Roaring expected_explained_readings = Roaring::bitmapOf(2, 0, 2);
				Roaring explained_readings = comp.explained;
				if ((explained_readings ^ expected_explained_readings).cardinality() != 0) {
					u_test.msg += "Using classic calculations, expected explained readings bitmap for E relative to A == " + expected_explained_readings.toString() + ", got " + explained_readings.toString() + "\n";
				}
				//Check that the genealogical cost of E relative to A is correct:
				float expected_cost = 3;
				float cost = comp.cost;
				if (cost != expected_cost) {
					u_test.msg += "Using classic calculations, expected genealogical cost for E relative to A == " + to_string(expected_cost) + ", got " + to_string(cost) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit witness_get_substemmata
		 */
		current_unit = "witness_get_substemmata";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Check if a witness has the expected number of minimum-cost substemmata:
				witness wit = witness("C", app);
				list<set_cover_solution> substemmata = wit.get_substemmata();
				unsigned int expected_substemmata_size = 1;
				unsigned int substemmata_size = (unsigned int) substemmata.size();
				if (substemmata_size != expected_substemmata_size) {
					u_test.msg += "Expected substemmata.size() == " + to_string(expected_substemmata_size) + ", got " + to_string(substemmata_size) + "\n";
				} else {
					//Check if a witness's minimum-cost substemma consists of the correct number of ancestors:
					set_cover_solution substemma = substemmata.front();
					unsigned int expected_substemma_rows_size = 1;
					unsigned int substemma_rows_size = (unsigned int) substemma.rows.size();
					if (substemma_rows_size != expected_substemma_rows_size) {
						u_test.msg += "Expected substemma.rows.size() == " + to_string(expected_substemma_rows_size) + ", got " + to_string(substemma_rows_size) + "\n";
					} else {
						//Check if the ancestors are correct:
						string expected_substemma_row_id = "B";
						string substemma_row_id = substemma.rows.front().id;
						if (substemma_row_id != expected_substemma_row_id) {
							u_test.msg += "Expected substemma.rows.front().id == {" + expected_substemma_row_id + "}, got {" + substemma_row_id + "}\n";
						}
					}
					float expected_substemma_cost = 2;
					float substemma_cost = substemma.cost;
					if (substemma_cost != expected_substemma_cost) {
						u_test.msg += "Expected substemma.cost == " + to_string(expected_substemma_cost) + ", got " + to_string(substemma_cost) + "\n";
					}
					unsigned int expected_substemma_agreements = 2;
					unsigned int substemma_agreements = substemma.agreements;
					if (substemma_agreements != expected_substemma_agreements) {
						u_test.msg += "Expected substemma.agreements == " + to_string(expected_substemma_agreements) + ", got " + to_string(substemma_agreements) + "\n";
					}
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		lib_test.modules.push_back(mod_test);
	}
	/**
	 * Module textual_flow
	 */
	current_module = "textual_flow";
	if (target_module.empty() || target_module == current_module) {
		//Initialize a container for module-wide test results:
		module_test mod_test;
		mod_test.name = current_module;
		mod_test.units = list<unit_test>();
		//Then proceed for each unit test:
		string current_unit;
		//Do pre-test work:
		pugi::xml_document doc;
		doc.load_file(TEST_XML.c_str());
		pugi::xml_node tei_node = doc.child("TEI");
		bool merge_splits = false;
		set<string> trivial_reading_types = set<string>({"defective", "orthographic"});
		set<string> dropped_reading_types = set<string>();
		apparatus app = apparatus(tei_node, merge_splits, trivial_reading_types, dropped_reading_types);
		variation_unit vu = app.get_variation_units()[3];
		list<witness> witnesses = list<witness>();
		for (string wit_id : app.get_list_wit()) {
			witness wit = witness(wit_id, app);
			witnesses.push_back(wit);
		}
		/**
		 * Unit textual_flow_constructor
		 */
		current_unit = "textual_flow_constructor";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a textual flow instance:
				textual_flow tf = textual_flow(vu, witnesses);
				//Make sure its label matches that of the variation unit:
				string expected_label = vu.get_label();
				string label = tf.get_label();
				if (label != expected_label) {
					u_test.msg += "Expected label == " + expected_label + ", got " + label + "\n";
				}
				//Make sure its readings list is the same length as the variation unit's readings list:
				unsigned int expected_n_readings = (unsigned int) vu.get_readings().size();
				if (tf.get_readings().size() != expected_n_readings) {
					u_test.msg += "Expected readings.size() == " + to_string(expected_n_readings) + ", got " + to_string(tf.get_readings().size()) + "\n";
				}
				//Make sure its connectivity value is the same as that of the variation unit:
				int expected_connectivity = vu.get_connectivity();
				if (tf.get_connectivity() != expected_connectivity) {
					u_test.msg += "Expected connectivity == " + to_string(expected_connectivity) + ", got " + to_string(tf.get_connectivity()) + "\n";
				}
				//Check that the diagram has the correct number of vertices:
				unsigned int expected_n_vertices = 5;
				unsigned int expected_n_edges = 9;
				if (tf.get_vertices().size() != expected_n_vertices) {
					u_test.msg += "Expected vertices.size() == " + to_string(expected_n_vertices) + ", got " + to_string(tf.get_vertices().size()) + "\n";
				}
				if (tf.get_edges().size() != expected_n_edges) {
					u_test.msg += "Expected edges.size() == " + to_string(expected_n_edges) + ", got " + to_string(tf.get_edges().size()) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		//Do more pre-test work:
		textual_flow tf = textual_flow(vu, witnesses);
		/**
		 * Unit test textual_flow_textual_flow_diagram_to_dot
		 */
		current_unit = "textual_flow_textual_flow_diagram_to_dot";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Test .dot serialization of complete textual flow graph:
				stringstream ss;
				tf.textual_flow_to_dot(ss, false);
				string out = ss.str();
				if (out.empty()) {
					u_test.msg += "The .dot serialization was empty.\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit test textual_flow_coherence_in_attestations_to_dot
		 */
		current_unit = "textual_flow_coherence_in_attestations_to_dot";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Test .dot serialization of coherence in attestations graph:
				stringstream ss;
				tf.coherence_in_attestations_to_dot(ss, "b", false);
				string out = ss.str();
				if (out.empty()) {
					u_test.msg += "The .dot serialization was empty.\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		/**
		 * Unit test textual_flow_coherence_in_variant_passages_to_dot
		 */
		current_unit = "textual_flow_coherence_in_variant_passages_to_dot";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Test .dot serialization of coherence in variant passages graph:
				stringstream ss;
				tf.coherence_in_variant_passages_to_dot(ss, false);
				string out = ss.str();
				if (out.empty()) {
					u_test.msg += "The .dot serialization was empty.\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		lib_test.modules.push_back(mod_test);
	}
	/**
	 * Module global_stemma
	 */
	current_module = "global_stemma";
	if (target_module.empty() || target_module == current_module) {
		//Initialize a container for module-wide test results:
		module_test mod_test;
		mod_test.name = current_module;
		mod_test.units = list<unit_test>();
		//Then proceed for each unit test:
		string current_unit;
		//Do pre-test work:
		pugi::xml_document doc;
		doc.load_file(TEST_XML.c_str());
		pugi::xml_node tei_node = doc.child("TEI");
		bool merge_splits = false;
		set<string> trivial_reading_types = set<string>({"defective", "orthographic"});
		set<string> dropped_reading_types = set<string>();
		apparatus app = apparatus(tei_node, merge_splits, trivial_reading_types, dropped_reading_types);
		list<witness> witnesses = list<witness>();
		for (string wit_id : app.get_list_wit()) {
			witness wit = witness(wit_id, app);
			witnesses.push_back(wit);
		}
		for (witness & wit : witnesses) {
			list<set_cover_solution> substemmata = wit.get_substemmata();
			list<string> stemmatic_ancestor_ids = list<string>();
			if (!substemmata.empty()) {
				set_cover_solution substemma = substemmata.front();
				for (set_cover_row row : substemma.rows) {
					stemmatic_ancestor_ids.push_back(row.id);
				}
			}
			wit.set_stemmatic_ancestor_ids(stemmatic_ancestor_ids);
		}
		/**
		 * Unit global_stemma_constructor
		 */
		current_unit = "global_stemma_constructor";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Construct a global stemma from a list of witnesses with optimized substemmata:
				global_stemma gs = global_stemma(witnesses);
				//Check that the graph is the size we expect:
				unsigned int expected_n_vertices = 5;
				unsigned int expected_n_edges = 4;
				if (gs.get_vertices().size() != expected_n_vertices) {
					u_test.msg += "Expected vertices.size() == " + to_string(expected_n_vertices) + ", got " + to_string(gs.get_vertices().size()) + "\n";
				}
				if (gs.get_edges().size() != expected_n_edges) {
					u_test.msg += "Expected edges.size() == " + to_string(expected_n_edges) + ", got " + to_string(gs.get_edges().size()) + "\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		//Do more pre-test work:
		global_stemma gs = global_stemma(witnesses);
		/**
		 * Unit global_stemma_to_dot
		 */
		current_unit = "global_stemma_to_dot";
		if (target_test.empty() || target_test == current_unit) {
			//Initialize a container for module-wide test results:
			unit_test u_test;
			u_test.name = current_unit;
			u_test.passed = false;
			u_test.msg = "";
			//Run the test:
			try {
				//Test .dot serialization:
				stringstream ss;
				gs.to_dot(ss, false, false);
				string out = ss.str();
				if (out.empty()) {
					u_test.msg += "The .dot serialization was empty.\n";
				}
				if (u_test.msg.empty()) {
					u_test.passed = true;
				}
			}
			catch (const exception & e) {
				u_test.msg += string(e.what()) + "\n";
			}
			mod_test.units.push_back(u_test);
		}
		lib_test.modules.push_back(mod_test);
	}
}

/**
 * Returns this autotest instance's library_test data structure.
 */
const library_test autotest::get_results() const {
	return lib_test;
}

/**
 * Entry point to the script. Runs all tests or just the specified tests.
 */
int main(int argc, char* argv[]) {
	//Read in the command-line options:
	bool list_modules = false;
	bool list_tests = false;
	string target_module = string();
	string target_test = string();
	try {
		cxxopts::Options options("autotest", "Runs unit tests for the library. If specified, runs specific tests or tests for specific modules.");
		options.custom_help("[-h] [--list-modules] [--list-tests] [-m module] [-t test]");
		options.add_options("")
				("h,help", "print this help")
				("list-modules", "lists all modules to be tested", cxxopts::value<bool>())
				("list-tests", "lists all unit tests", cxxopts::value<bool>())
				("m,module", "name of specific module to test", cxxopts::value<string>())
				("t,test", "name of specific test to run", cxxopts::value<string>());
		auto result = options.parse(argc, argv);
		//Print help documentation and exit if specified:
		if (result.count("help")) {
			cout << options.help({""}) << endl;
			exit(0);
		}
		//Parse the optional arguments:
		if (result.count("list_modules")) {
			list_modules = result["list_modules"].as<bool>();
		}
		if (result.count("list_tests")) {
			list_tests = result["list_tests"].as<bool>();
		}
		if (result.count("m")) {
			target_module = result["m"].as<string>();
		}
		if (result.count("t")) {
			target_test = result["t"].as<string>();
		}
	}
	catch (const cxxopts::OptionException & e) {
		cerr << "Error parsing options: " << e.what() << endl;
		exit(-1);
	}
	//Initialize the list of test modules:
	list<string> modules = list<string>({
		"common",
		"local_stemma",
		"variation_unit",
		"apparatus",
		"set_cover_solver",
		"witness",
		"textual_flow",
		"global_stemma"
	});
	//Initialize the map of unit tests, keyed by parent module name:
	map<string, list<string>> tests_by_module = map<string, list<string>>({
		{"common", {"common_read_xml"}},
		{"local_stemma", {"local_stemma_constructor_1", "local_stemma_constructor_2", "local_stemma_path_exists", "local_stemma_get_path", "local_stemma_common_ancestor_exists", "local_stemma_to_dot"}},
		{"variation_unit", {"variation_unit_constructor_1", "variation_unit_constructor_2", "variation_unit_constructor_3", "variation_unit_constructor_4"}},
		{"apparatus", {"apparatus_constructor", "apparatus_get_extant_passages_for_witness"}},
		{"set_cover_solver", {"set_cover_solver_constructor", "set_cover_solver_get_unique_rows", "set_cover_solver_get_trivial_solution", "set_cover_solver_get_greedy_solution"}},
		{"witness", {"witness_constructor_1", "witness_constructor_2", "witness_get_genealogical_comparison_for_witness_1", "witness_get_genealogical_comparison_for_witness_2", "witness_get_genealogical_comparison_for_witness_3", "witness_get_substemmata"}},
		{"textual_flow", {"textual_flow_constructor", "textual_flow_textual_flow_to_dot", "textual_flow_coherence_in_attestations_to_dot", "textual_flow_coherence_in_variant_passages_to_dot"}},
		{"global_stemma", {"global_stemma_constructor", "global_stemma_to_dot"}}
	});
	//Initialize an autotest instance with these containers:
	autotest at = autotest(modules, tests_by_module);
	//If the list-modules or list-tests flags are set,
	//then print out whichever list is more specific:
	if (list_tests) {
		at.print_tests();
	}
	else if (list_modules) {
		at.print_modules();
	}
	//If a target test was specified, then take note of it:
	if (!target_test.empty()) {
		bool success = at.set_target_test(target_test);
		if (!success) {
			cerr << "Error: the specified test " << target_test << " is not the name of a unit test." << endl;
			exit(1);
		}
	}
	//Otherwise, if a target module was specified, then take note of it:
	else if (!target_module.empty()) {
		bool success = at.set_target_module(target_module);
		if (!success) {
			cerr << "Error: the specified module " << target_module << " is not the name of a module." << endl;
			exit(1);
		}
	}
	at.run();
	//Get the results:
	library_test lib_test = at.get_results();
	//Keep tallies of all tests performed and all tests passed in the library:
	unsigned int lib_tests_performed = 0;
	unsigned int lib_tests_passed = 0;
	cout << "LIBRARY " << lib_test.name << "\n\n";
	//Proceed for each module tested:
	for (module_test mod_test : lib_test.modules) {
		//Keep tallies of all tests performed and all tests passed in the module:
		unsigned int mod_tests_performed = 0;
		unsigned int mod_tests_passed = 0;
		cout << "\tMODULE " << mod_test.name << "\n\n";
		//Proceed for each unit test:
		for (unit_test u_test : mod_test.units) {
			cout << "\t\tTEST " << u_test.name << " ";
			mod_tests_performed++;
			if (u_test.passed) {
				cout << "PASS\n";
				mod_tests_passed++;
			}
			else {
				cout << "<<FAIL>>: " << u_test.msg;
			}
		}
		//Add this module's totals to the totals for the library:
		lib_tests_performed += mod_tests_performed;
		lib_tests_passed += mod_tests_passed;
		//Report the totals for this module:
		cout << "\t" << "==================================" << "\n";
		cout << "\t" << mod_tests_passed << " of " << mod_tests_performed << " tests passed.\n\n";
	}
	//Report the totals for the library:
	cout << "==================================\n";
	cout << lib_tests_passed << " of " << lib_tests_performed << " tests passed total.\n\n";
	//Return a successful exit code only if all tests have been passed:
	return lib_tests_passed == lib_tests_performed ? 0 : 1;
}
